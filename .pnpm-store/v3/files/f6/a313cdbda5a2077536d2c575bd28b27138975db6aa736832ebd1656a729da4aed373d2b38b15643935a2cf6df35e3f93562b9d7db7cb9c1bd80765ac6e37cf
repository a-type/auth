// @unocss-include
"use strict";
'use client';
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LiveUpdateTextField = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = require("react");
const utils_1 = require("@a-type/utils");
const Input_js_1 = require("../input/Input.js");
const TextArea_js_1 = require("../textArea/TextArea.js");
/**
 * An extension of TextField which keeps a local realtime value in state and
 * periodically reports changes to the parent. Use this to connect
 * to the API and update a value from the field directly.
 *
 * This component is optimistic and will not respond to external changes while focused.
 */
exports.LiveUpdateTextField = (0, react_1.forwardRef)(function LiveUpdateTextField(_a, ref) {
    var { value, onChange, debounceMs = 500, onFocus, onBlur, textArea, type } = _a, rest = __rest(_a, ["value", "onChange", "debounceMs", "onFocus", "onBlur", "textArea", "type"]);
    const [displayValue, setDisplayValue] = (0, react_1.useState)(value || '');
    const ignoreUpdates = (0, react_1.useRef)(false);
    const didChange = (0, react_1.useRef)(false);
    const handleFocus = (0, react_1.useCallback)((ev) => {
        onFocus === null || onFocus === void 0 ? void 0 : onFocus(ev);
        ignoreUpdates.current = true;
    }, [onFocus]);
    const handleBlur = (0, react_1.useCallback)((ev) => {
        onBlur === null || onBlur === void 0 ? void 0 : onBlur(ev);
        ignoreUpdates.current = false;
        // immediately send update if the user typed anything.
        // otherwise pull the latest remote value
        if (didChange.current) {
            onChange === null || onChange === void 0 ? void 0 : onChange(displayValue);
        }
        else {
            setDisplayValue(value || '');
        }
        didChange.current = false;
    }, [onBlur, displayValue, onChange, value]);
    (0, react_1.useEffect)(() => {
        if (ignoreUpdates.current) {
            return;
        }
        setDisplayValue(value || '');
    }, [value]);
    // every once in a while, send an update to parent
    const debouncedOnChange = (0, react_1.useMemo)(() => (0, utils_1.debounce)(onChange || (() => { }), debounceMs), [onChange, debounceMs]);
    // update local state instantly and parent eventually
    const handleChange = (0, react_1.useCallback)((ev) => {
        setDisplayValue(ev.target.value);
        debouncedOnChange(ev.target.value);
        didChange.current = true;
    }, [debouncedOnChange]);
    if (textArea) {
        return ((0, jsx_runtime_1.jsx)(TextArea_js_1.TextArea, Object.assign({ ref: ref, onFocus: handleFocus, onBlur: handleBlur, value: displayValue, onChange: handleChange, autoSize: true }, rest)));
    }
    else {
        return ((0, jsx_runtime_1.jsx)(Input_js_1.Input, Object.assign({ ref: ref, onFocus: handleFocus, onBlur: handleBlur, value: displayValue, onChange: handleChange, type: type }, rest)));
    }
});
//# sourceMappingURL=LiveUpdateTextField.js.map