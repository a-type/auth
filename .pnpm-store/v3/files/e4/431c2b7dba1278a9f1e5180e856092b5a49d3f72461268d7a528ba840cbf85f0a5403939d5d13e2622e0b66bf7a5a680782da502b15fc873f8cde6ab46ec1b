// @unocss-include
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
export class Particles {
    constructor({ initialPoolSize }) {
        this.canvas = null;
        this.ctx = null;
        this.state = 'paused';
        this.lastFrameTimestamp = 0;
        this.disabled = false;
        this.freeParticles = [];
        // keep canvas render size the same as its actual size
        this.resizeObserver = new ResizeObserver((entries) => {
            for (const entry of entries) {
                const { width, height } = entry.contentRect;
                if (this.canvas) {
                    this.canvas.width = width;
                    this.canvas.height = height;
                }
            }
        });
        this.setCanvas = (canvas) => {
            if (this.disabled) {
                return;
            }
            if (this.canvas) {
                this.resizeObserver.unobserve(this.canvas);
            }
            this.canvas = canvas;
            this.ctx = canvas ? canvas.getContext('2d') : null;
            if (!canvas) {
                this.pause();
            }
            else {
                this.resume();
                this.resizeObserver.observe(canvas);
            }
        };
        this.resume = () => {
            if (this.disabled) {
                return;
            }
            this.state = 'running';
            this.lastFrameTimestamp = performance.now();
            requestAnimationFrame(this.draw);
        };
        this.pause = () => {
            this.state = 'paused';
        };
        this.draw = (timestamp) => {
            if (this.state === 'paused') {
                return;
            }
            const ctx = this.ctx;
            if (!ctx || !this.canvas) {
                console.warn('No canvas context');
                this.pause();
                return;
            }
            const delta = timestamp - this.lastFrameTimestamp;
            ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            this.renderParticles(ctx, delta);
            requestAnimationFrame(this.draw);
            this.lastFrameTimestamp = timestamp;
        };
        this.renderParticles = (ctx, delta) => {
            let freed = 0;
            for (let i = 0; i < this.particles.length; i++) {
                const particle = this.particles[i];
                if (particle.render(ctx, delta)) {
                    particle.dispose();
                    this.freeParticles.push(particle);
                    freed++;
                }
            }
            if (freed) {
                console.log('Freed particles', freed);
            }
        };
        this.addParticles = (spawn) => {
            // wrap in RAF because initializers often use element dimensions
            requestAnimationFrame(() => {
                if (this.freeParticles.length < spawn.count) {
                    this.extendPool(spawn.count - this.freeParticles.length);
                }
                for (let i = 0; i < spawn.count; i++) {
                    const particle = this.freeParticles.pop();
                    const initials = spawn.initializer(i);
                    if (!particle) {
                        throw new Error('Particle allocation failed');
                    }
                    particle.allocate(initials.x, initials.y, initials.velocityX, initials.velocityY, initials.drag, initials.lifespan, spawn.behavior);
                }
                console.log('Allocated particles', spawn.count);
            });
        };
        this.extendPool = (size) => {
            for (let i = 0; i < size; i++) {
                const particle = new Particle();
                this.particles.push(particle);
                this.freeParticles.push(particle);
            }
        };
        this.elementExplosion = elementExplosion;
        this.windowBorderExplosion = windowBorderExplosion;
        // if prefers-reduced-motion is set, disable particles
        this.disabled =
            typeof window === 'undefined' ||
                window.matchMedia('(prefers-reduced-motion: reduce)').matches;
        if (this.disabled) {
            initialPoolSize = 0;
        }
        this.particles = new Array(initialPoolSize);
        for (let i = 0; i < initialPoolSize; i++) {
            this.particles[i] = new Particle();
            this.freeParticles.push(this.particles[i]);
        }
    }
}
class Particle {
    constructor() {
        this.disposed = true;
        this.lifetime = 0;
        this.lifespan = 0;
        this.x = -1;
        this.y = -1;
        this.behavior = nullBehavior;
        this.velocityX = 0;
        this.velocityY = 0;
        this.drag = 0;
        this.allocate = (x, y, velocityX, velocityY, drag, lifespan, behavior) => {
            this.disposed = false;
            this.lifetime = 0;
            this.lifespan = lifespan;
            this.x = x;
            this.y = y;
            this.velocityX = velocityX;
            this.velocityY = velocityY;
            this.drag = drag;
            this.behavior = behavior;
        };
        this.dispose = () => {
            this.disposed = true;
        };
        this.render = (ctx, delta) => {
            if (this.disposed) {
                return;
            }
            this.lifetime += delta;
            this.x += this.velocityX * delta;
            this.y += this.velocityY * delta;
            this.velocityX *= 1 - this.drag * delta;
            this.velocityY *= 1 - this.drag * delta;
            this.behavior(ctx, this.x, this.y, this.lifetime, this.lifespan);
            return this.lifetime >= this.lifespan;
        };
    }
}
const nullBehavior = () => { };
export function createCircleParticles({ count, startRadius = 4, endRadius = 0, initializer, color = YELLOW, }) {
    const colorMixer = Array.isArray(color)
        ? colorInterpolate(color)
        : colorInterpolate([color, color]);
    return {
        count,
        behavior: (ctx, x, y, lifetime, lifespan) => {
            const lifetimePercentage = Math.max(0, Math.min(1, lifetime / lifespan));
            const finalColor = colorMixer(lifetimePercentage);
            const radius = Math.max(0, startRadius + (endRadius - startRadius) * lifetimePercentage);
            ctx.beginPath();
            ctx.fillStyle = colorToString(finalColor);
            ctx.arc(x, y, radius, 0, 2 * Math.PI);
            ctx.fill();
        },
        initializer,
    };
}
function fuzz(value, fuzz) {
    return value + (Math.random() - 0.5) * fuzz;
}
export const createElementBorderInitializer = ({ element, borders = ['top', 'right', 'bottom', 'left'], force = 0.1, drag = 0.001, lifespan = 2000, forceFuzz = 0.05, angleFuzz = 0.02, margin = 0, }) => {
    // randomly spawn particles around the border of the element by 'unwrapping' the selected borders as
    // a single theoretical line, picking a random point on the line, and then converting that point
    // back to a point on the border.
    return (index) => {
        const bounds = element.getBoundingClientRect();
        const rect = {
            left: bounds.left,
            top: bounds.top,
            right: bounds.right,
            bottom: bounds.bottom,
            width: bounds.width,
            height: bounds.height,
        };
        if (margin) {
            rect.left -= margin;
            rect.top -= margin;
            rect.right += margin;
            rect.bottom += margin;
        }
        const borderLengths = borders.map((border) => {
            switch (border) {
                case 'top':
                case 'bottom':
                    return rect.width;
                case 'left':
                case 'right':
                    return rect.height;
            }
        });
        const totalBorderLength = borderLengths.reduce((a, b) => a + b, 0);
        const randomPoint = Math.random() * totalBorderLength;
        let borderIndex = 0;
        let borderLength = borderLengths[0];
        while (randomPoint > borderLength) {
            borderIndex++;
            borderLength += borderLengths[borderIndex];
        }
        const border = borders[borderIndex];
        const borderOffset = randomPoint - (borderLength - borderLengths[borderIndex]);
        let x = 0;
        let y = 0;
        let velocityX = 0;
        let velocityY = 0;
        switch (border) {
            case 'top':
                x = rect.left + borderOffset;
                y = rect.top;
                break;
            case 'right':
                x = rect.right;
                y = rect.top + borderOffset;
                break;
            case 'bottom':
                x = rect.left + borderOffset;
                y = rect.bottom;
                break;
            case 'left':
                x = rect.left;
                y = rect.top + borderOffset;
                break;
        }
        // velocity is away from the center of the element
        const center = {
            x: rect.left + rect.width / 2,
            y: rect.top + rect.height / 2,
        };
        // special case: width/height is 0
        let angle = rect.width === 0 || rect.height === 0
            ? Math.random() * (Math.PI * 2)
            : Math.atan2(y - center.y, x - center.x);
        angle = fuzz(angle, angleFuzz);
        const totalForce = fuzz(force, forceFuzz);
        velocityX = Math.cos(angle) * totalForce;
        velocityY = Math.sin(angle) * totalForce;
        return { x, y, velocityX, velocityY, drag, lifespan };
    };
};
const YELLOW = {
    space: 'rgb',
    values: [249, 231, 148],
    opacity: 1,
};
const TRANSPARENT = {
    space: 'rgb',
    values: [255, 255, 255],
    opacity: 0,
};
export const elementExplosion = (_a) => {
    var { element, color = [YELLOW, TRANSPARENT], borders, lifespan, force, drag, forceFuzz, angleFuzz, margin } = _a, rest = __rest(_a, ["element", "color", "borders", "lifespan", "force", "drag", "forceFuzz", "angleFuzz", "margin"]);
    return createCircleParticles(Object.assign({ initializer: createElementBorderInitializer({
            element,
            borders,
            lifespan,
            force,
            drag,
            forceFuzz,
            angleFuzz,
            margin,
        }), color }, rest));
};
export const createWindowBorderInitializer = ({ force = 0.1, drag = 0.001, border = 'top', lifespan = 2000, }) => {
    return (index) => {
        const rect = document.body.getBoundingClientRect();
        let x = 0;
        let y = 0;
        let velocityX = 0;
        let velocityY = 0;
        switch (border) {
            case 'top':
                velocityY = force * (Math.random() + 0.25);
                x = rect.left + Math.random() * rect.width;
                y = rect.top;
                break;
            case 'right':
                velocityX = -force * (Math.random() + 0.25);
                x = rect.right;
                y = rect.top + Math.random() * rect.height;
                break;
            case 'bottom':
                velocityY = -force * (Math.random() + 0.25);
                x = rect.left + Math.random() * rect.width;
                y = rect.bottom;
                break;
            case 'left':
                velocityX = force * (Math.random() + 0.25);
                x = rect.left;
                y = rect.top + Math.random() * rect.height;
                break;
        }
        return { x, y, velocityX, velocityY, drag, lifespan };
    };
};
export const windowBorderExplosion = (_a) => {
    var { color = [YELLOW, TRANSPARENT], border = 'top', lifespan } = _a, rest = __rest(_a, ["color", "border", "lifespan"]);
    return createCircleParticles(Object.assign({ initializer: createWindowBorderInitializer({
            border,
            lifespan,
        }), color }, rest));
};
function colorInterpolate(colors) {
    return function interpolate(value) {
        if (colors[0].space !== colors[1].space) {
            throw new Error('Cannot interpolate between colors of different spaces');
        }
        if (colors[0].space === 'rgb') {
            return interpolateRgb(colors[0], colors[1], value);
        }
        else {
            throw new Error(`Unsupported color space ${colors[0].space}`);
        }
    };
}
function interpolateRgb(color1, color2, value) {
    const result = {
        space: 'rgb',
        values: [0, 0, 0],
        opacity: 0,
    };
    for (let i = 0; i < 3; i++) {
        result.values[i] =
            color1.values[i] + (color2.values[i] - color1.values[i]) * value;
    }
    result.opacity = color1.opacity + (color2.opacity - color1.opacity) * value;
    return result;
}
function colorToString(color) {
    if (color.space === 'rgb') {
        return colorRgbToString(color);
    }
    throw new Error(`Unsupported color space ${color.space}`);
}
function colorRgbToString(color) {
    return `rgba(${color.values[0]}, ${color.values[1]}, ${color.values[2]}, ${color.opacity})`;
}
//# sourceMappingURL=particlesState.js.map