// @unocss-include
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import classNames from 'clsx';
import { createContext, forwardRef, useContext, useEffect, useRef, useState, } from 'react';
import { Button } from '../button.js';
import { Icon } from '../icon.js';
import { Select, SelectContent, SelectItem, SelectTrigger } from '../select.js';
import { Slot } from '@radix-ui/react-slot';
import { withClassName } from '../../hooks.js';
const CameraContext = createContext({
    triggerCapture: () => { },
    selectedDeviceId: 'default',
    selectDeviceId: () => { },
    devices: [],
});
export const CameraRoot = forwardRef(function Camera(_a, ref) {
    var { className, onCapture, children, facingMode, format = 'image/png' } = _a, rest = __rest(_a, ["className", "onCapture", "children", "facingMode", "format"]);
    const videoRef = useRef(null);
    const [devices, setDevices] = useState([]);
    const [stream, setStream] = useState();
    useEffect(() => {
        var _a;
        (_a = navigator.mediaDevices) === null || _a === void 0 ? void 0 : _a.enumerateDevices().then((devices) => {
            setDevices(devices.filter((device) => device.kind === 'videoinput'));
        });
    }, [!!stream]);
    const [selectedDeviceId, setSelectedDeviceId] = useState();
    useEffect(() => {
        const init = () => {
            var _a;
            (_a = navigator.mediaDevices) === null || _a === void 0 ? void 0 : _a.getUserMedia({
                video: {
                    deviceId: selectedDeviceId,
                    facingMode,
                },
            }).then((s) => {
                setStream(s);
            });
        };
        init();
        // reconnect if browser was backgrounded
        const reconnect = () => {
            if ((stream === null || stream === void 0 ? void 0 : stream.active) || document.visibilityState !== 'visible') {
                return;
            }
            init();
        };
        document.addEventListener('visibilitychange', reconnect);
    }, [selectedDeviceId, facingMode]);
    useEffect(() => {
        return () => {
            stream === null || stream === void 0 ? void 0 : stream.getTracks().forEach((track) => track.stop());
        };
    }, [stream]);
    useEffect(() => {
        const video = videoRef.current;
        if (video && stream) {
            video.srcObject = stream;
            return () => {
                video.srcObject = null;
            };
        }
    }, [stream]);
    const [capture, setCapture] = useState();
    useEffect(() => {
        if (typeof window !== 'undefined' && 'ImageCapture' in window) {
            const videoTrack = stream === null || stream === void 0 ? void 0 : stream.getVideoTracks()[0];
            if (videoTrack) {
                const capturer = new ImageCapture(videoTrack);
                setCapture(capturer);
                capturer.getPhotoCapabilities().then((capabilities) => {
                    console.log('ImageCapture capabilities:', capabilities);
                });
            }
        }
    }, [stream]);
    const triggerCapture = () => {
        var _a;
        if (capture) {
            capture.takePhoto().then((blob) => {
                const file = new File([blob], `image.${format.split('/')[1]}`, {
                    type: format,
                });
                onCapture === null || onCapture === void 0 ? void 0 : onCapture(file);
            });
        }
        else {
            // ImageCapture not supported, fallback to
            // canvas capture
            const video = videoRef.current;
            if (video) {
                const canvas = document.createElement('canvas');
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                (_a = canvas.getContext('2d')) === null || _a === void 0 ? void 0 : _a.drawImage(video, 0, 0);
                const data = canvas.toDataURL(format);
                const file = dataURItoFile(data);
                onCapture === null || onCapture === void 0 ? void 0 : onCapture(file);
            }
        }
    };
    return (_jsx(CameraContext.Provider, Object.assign({ value: {
            devices,
            triggerCapture,
            selectedDeviceId,
            selectDeviceId: setSelectedDeviceId,
        } }, { children: _jsxs("div", Object.assign({ ref: ref, className: classNames('layer-components:[font-family:inherit] layer-components:text-white layer-components:bg-black layer-components:rounded-lg layer-components:overflow-hidden layer-components:min-w-4 layer-components:min-h-4 layer-components:relative', className) }, rest, { children: [_jsx("video", { ref: videoRef, className: "w-full h-full object-cover", autoPlay: true, muted: true, playsInline: true }), children] })) })));
});
export const CameraShutterButton = forwardRef(function CameraShutterButton(_a, ref) {
    var { asChild, onClick } = _a, rest = __rest(_a, ["asChild", "onClick"]);
    const Comp = asChild ? Slot : StyledShutterButton;
    const { triggerCapture } = useContext(CameraContext);
    return (_jsx(Comp, Object.assign({ ref: ref, "aria-label": asChild ? undefined : 'Capture photo', onClick: (ev) => {
            triggerCapture();
            onClick === null || onClick === void 0 ? void 0 : onClick(ev);
        } }, rest)));
});
const StyledShutterButton = withClassName('button', 'absolute bottom-3 left-1/2 -translate-x-1/2 w-16 h-16 bg-white rounded-full cursor-pointer border-2 border-black border-solid ring-2 ring-white opacity-80', 'hover:bg-gray-1 hover:opacity-100', 'focus-visible:bg-gray-2', 'focus:ring-primary focus:outline-none focus:opacity-100', 'sm:w-8 sm:h-8');
export const CameraDeviceSelector = (props) => {
    const { devices, selectDeviceId, selectedDeviceId } = useContext(CameraContext);
    const swapCamera = () => {
        if (selectedDeviceId) {
            const index = devices.findIndex((device) => device.deviceId === selectedDeviceId);
            if (index === -1) {
                return;
            }
            selectDeviceId(devices[(index + 1) % devices.length].deviceId);
        }
        else {
            selectDeviceId(devices[0].deviceId);
        }
    };
    if (!devices.length || devices.length === 1)
        return null;
    if (devices.length === 2) {
        return (_jsx(Button, Object.assign({ size: "icon", color: "ghost", className: "absolute bottom-2 left-2 text-white", onClick: swapCamera }, { children: _jsx(Icon, { name: "refresh" }) })));
    }
    return (_jsxs(Select, Object.assign({ value: selectedDeviceId || 'default', onValueChange: selectDeviceId }, { children: [_jsx(SelectTrigger, Object.assign({ asChild: true }, { children: _jsx(Button, Object.assign({ size: "icon", color: "ghost", className: "absolute bottom-2 left-2 text-white" }, { children: _jsx(Icon, { name: "refresh" }) })) })), _jsx(SelectContent, { children: devices.map((device) => (_jsx(SelectItem, Object.assign({ value: device.deviceId }, { children: device.label }), device.deviceId))) })] })));
};
function dataURItoFile(dataURI) {
    // convert base64/URLEncoded data component to raw binary data held in a string
    var byteString;
    if (dataURI.split(',')[0].indexOf('base64') >= 0)
        byteString = atob(dataURI.split(',')[1]);
    else
        byteString = unescape(dataURI.split(',')[1]);
    // separate out the mime component
    var mimeString = dataURI.split(',')[0].split(':')[1].split(';')[0];
    // write the bytes of the string to a typed array
    var ia = new Uint8Array(byteString.length);
    for (var i = 0; i < byteString.length; i++) {
        ia[i] = byteString.charCodeAt(i);
    }
    const fileExt = mimeString.split('/')[1];
    return new File([ia], `image.${fileExt}`, { type: mimeString });
}
//# sourceMappingURL=Camera.js.map