// @unocss-include
"use strict";
'use client';
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ImageUploader = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const clsx_1 = __importDefault(require("clsx"));
const react_1 = require("react");
const icon_js_1 = require("../icon.js");
const button_js_1 = require("../button.js");
const camera_js_1 = require("../camera.js");
/**
 * Renders an image if one is already set, and allows either clicking
 * on the image to select a new one, or dragging a new image onto the
 * component to replace the existing one.
 */
function ImageUploader(_a) {
    var { value, onChange: handleChange, maxDimension, facingMode } = _a, rest = __rest(_a, ["value", "onChange", "maxDimension", "facingMode"]);
    const inputId = (0, react_1.useId)();
    const [dragging, setDragging] = (0, react_1.useState)(false);
    const [draggingOver, setDraggingOver] = (0, react_1.useState)(false);
    const onDragEnter = (0, react_1.useCallback)((e) => {
        e.preventDefault();
        e.stopPropagation();
        setDraggingOver(true);
    }, []);
    const onDragLeave = (0, react_1.useCallback)((e) => {
        e.preventDefault();
        e.stopPropagation();
        setDraggingOver(false);
    }, []);
    const onDragOver = (0, react_1.useCallback)((e) => {
        e.preventDefault();
        e.stopPropagation();
        setDraggingOver(true);
    }, []);
    const onChange = (0, react_1.useCallback)(async (file) => {
        if (!file) {
            handleChange(null);
        }
        else if (maxDimension) {
            const { readAndCompressImage } = await import('browser-image-resizer');
            const resizedImage = await readAndCompressImage(file, {
                maxWidth: maxDimension,
                maxHeight: maxDimension,
                mimeType: file.type,
            });
            handleChange(new File([resizedImage], file.name, { type: file.type }));
        }
        else {
            handleChange(file);
        }
    }, [handleChange, maxDimension]);
    const onDrop = (0, react_1.useCallback)((e) => {
        e.preventDefault();
        e.stopPropagation();
        setDraggingOver(false);
        if (e.dataTransfer.files.length > 0) {
            onChange(e.dataTransfer.files[0]);
        }
    }, [onChange]);
    const onDragStart = (0, react_1.useCallback)((e) => {
        e.preventDefault();
        e.stopPropagation();
        setDragging(true);
    }, []);
    const onDragEnd = (0, react_1.useCallback)((e) => {
        e.preventDefault();
        e.stopPropagation();
        setDragging(false);
    }, []);
    const onFileChange = (0, react_1.useCallback)((e) => {
        if (e.target.files && e.target.files.length > 0) {
            onChange(e.target.files[0]);
        }
    }, [onChange]);
    const onFileClick = (0, react_1.useCallback)((e) => {
        e.stopPropagation();
    }, []);
    const [cameraOpen, setCameraOpen] = (0, react_1.useState)(false);
    const openCamera = () => setCameraOpen(true);
    return ((0, jsx_runtime_1.jsxs)("div", Object.assign({ className: (0, clsx_1.default)('relative overflow-hidden', rest.className), onDragEnter: onDragEnter, onDragLeave: onDragLeave, onDragOver: onDragOver, onDrop: onDrop, onDragStart: onDragStart, onDragEnd: onDragEnd }, { children: [value ? ((0, jsx_runtime_1.jsx)("img", { src: value, className: "w-full h-full object-cover object-center" })) : null, !value && ((0, jsx_runtime_1.jsxs)("div", Object.assign({ className: (0, clsx_1.default)('absolute inset-0 flex flex-col items-center justify-center gap-3 bg-[rgba(0,0,0,0.05)]', {
                    '!bg-[rgba(0,0,0,0.1)]': draggingOver,
                }) }, { children: [(0, jsx_runtime_1.jsx)("input", { type: "file", accept: "image/*", onChange: onFileChange, onClick: onFileClick, className: "absolute inset--99999 op-0", id: inputId }), (0, jsx_runtime_1.jsx)(button_js_1.Button, Object.assign({ color: "ghost", asChild: true }, { children: (0, jsx_runtime_1.jsxs)("label", Object.assign({ htmlFor: inputId }, { children: [(0, jsx_runtime_1.jsx)(icon_js_1.Icon, { name: "upload" }), (0, jsx_runtime_1.jsx)("span", { children: dragging ? 'Drop' : 'Upload' })] })) })), (0, jsx_runtime_1.jsxs)(button_js_1.Button, Object.assign({ color: "ghost", onClick: openCamera }, { children: [(0, jsx_runtime_1.jsx)(icon_js_1.Icon, { name: "camera" }), (0, jsx_runtime_1.jsx)("span", { children: "Camera" })] }))] }))), !value && cameraOpen && ((0, jsx_runtime_1.jsxs)(camera_js_1.CameraRoot, Object.assign({ className: "absolute w-full h-full z-1", format: "image/png", onCapture: (file) => {
                    onChange(file);
                    setCameraOpen(false);
                }, facingMode: facingMode }, { children: [(0, jsx_runtime_1.jsx)(camera_js_1.CameraShutterButton, {}), (0, jsx_runtime_1.jsx)(camera_js_1.CameraDeviceSelector, {}), (0, jsx_runtime_1.jsx)(button_js_1.Button, Object.assign({ onClick: () => setCameraOpen(false), color: "ghost", size: "icon", className: "text-white absolute top-2 right-2" }, { children: (0, jsx_runtime_1.jsx)(icon_js_1.Icon, { name: "x" }) }))] }))), value && ((0, jsx_runtime_1.jsx)(button_js_1.Button, Object.assign({ color: "ghost", size: "icon", className: "absolute top-2 right-2 w-32px h-32px border-none p-2 cursor-pointer bg-white color-black rounded-full transition-colors shadow-sm", onClick: () => onChange(null) }, { children: (0, jsx_runtime_1.jsx)(icon_js_1.Icon, { name: "x" }) })))] })));
}
exports.ImageUploader = ImageUploader;
//# sourceMappingURL=ImageUploader.js.map