// @unocss-include
'use client';
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import classNames from 'clsx';
import { useCallback, useId, useState } from 'react';
import { Icon } from '../icon.js';
import { Button } from '../button.js';
import { CameraDeviceSelector, CameraRoot, CameraShutterButton, } from '../camera.js';
/**
 * Renders an image if one is already set, and allows either clicking
 * on the image to select a new one, or dragging a new image onto the
 * component to replace the existing one.
 */
export function ImageUploader(_a) {
    var { value, onChange: handleChange, maxDimension, facingMode } = _a, rest = __rest(_a, ["value", "onChange", "maxDimension", "facingMode"]);
    const inputId = useId();
    const [dragging, setDragging] = useState(false);
    const [draggingOver, setDraggingOver] = useState(false);
    const onDragEnter = useCallback((e) => {
        e.preventDefault();
        e.stopPropagation();
        setDraggingOver(true);
    }, []);
    const onDragLeave = useCallback((e) => {
        e.preventDefault();
        e.stopPropagation();
        setDraggingOver(false);
    }, []);
    const onDragOver = useCallback((e) => {
        e.preventDefault();
        e.stopPropagation();
        setDraggingOver(true);
    }, []);
    const onChange = useCallback(async (file) => {
        if (!file) {
            handleChange(null);
        }
        else if (maxDimension) {
            const { readAndCompressImage } = await import('browser-image-resizer');
            const resizedImage = await readAndCompressImage(file, {
                maxWidth: maxDimension,
                maxHeight: maxDimension,
                mimeType: file.type,
            });
            handleChange(new File([resizedImage], file.name, { type: file.type }));
        }
        else {
            handleChange(file);
        }
    }, [handleChange, maxDimension]);
    const onDrop = useCallback((e) => {
        e.preventDefault();
        e.stopPropagation();
        setDraggingOver(false);
        if (e.dataTransfer.files.length > 0) {
            onChange(e.dataTransfer.files[0]);
        }
    }, [onChange]);
    const onDragStart = useCallback((e) => {
        e.preventDefault();
        e.stopPropagation();
        setDragging(true);
    }, []);
    const onDragEnd = useCallback((e) => {
        e.preventDefault();
        e.stopPropagation();
        setDragging(false);
    }, []);
    const onFileChange = useCallback((e) => {
        if (e.target.files && e.target.files.length > 0) {
            onChange(e.target.files[0]);
        }
    }, [onChange]);
    const onFileClick = useCallback((e) => {
        e.stopPropagation();
    }, []);
    const [cameraOpen, setCameraOpen] = useState(false);
    const openCamera = () => setCameraOpen(true);
    return (_jsxs("div", Object.assign({ className: classNames('relative overflow-hidden', rest.className), onDragEnter: onDragEnter, onDragLeave: onDragLeave, onDragOver: onDragOver, onDrop: onDrop, onDragStart: onDragStart, onDragEnd: onDragEnd }, { children: [value ? (_jsx("img", { src: value, className: "w-full h-full object-cover object-center" })) : null, !value && (_jsxs("div", Object.assign({ className: classNames('absolute inset-0 flex flex-col items-center justify-center gap-3 bg-[rgba(0,0,0,0.05)]', {
                    '!bg-[rgba(0,0,0,0.1)]': draggingOver,
                }) }, { children: [_jsx("input", { type: "file", accept: "image/*", onChange: onFileChange, onClick: onFileClick, className: "absolute inset--99999 op-0", id: inputId }), _jsx(Button, Object.assign({ color: "ghost", asChild: true }, { children: _jsxs("label", Object.assign({ htmlFor: inputId }, { children: [_jsx(Icon, { name: "upload" }), _jsx("span", { children: dragging ? 'Drop' : 'Upload' })] })) })), _jsxs(Button, Object.assign({ color: "ghost", onClick: openCamera }, { children: [_jsx(Icon, { name: "camera" }), _jsx("span", { children: "Camera" })] }))] }))), !value && cameraOpen && (_jsxs(CameraRoot, Object.assign({ className: "absolute w-full h-full z-1", format: "image/png", onCapture: (file) => {
                    onChange(file);
                    setCameraOpen(false);
                }, facingMode: facingMode }, { children: [_jsx(CameraShutterButton, {}), _jsx(CameraDeviceSelector, {}), _jsx(Button, Object.assign({ onClick: () => setCameraOpen(false), color: "ghost", size: "icon", className: "text-white absolute top-2 right-2" }, { children: _jsx(Icon, { name: "x" }) }))] }))), value && (_jsx(Button, Object.assign({ color: "ghost", size: "icon", className: "absolute top-2 right-2 w-32px h-32px border-none p-2 cursor-pointer bg-white color-black rounded-full transition-colors shadow-sm", onClick: () => onChange(null) }, { children: _jsx(Icon, { name: "x" }) })))] })));
}
//# sourceMappingURL=ImageUploader.js.map