// @unocss-include
'use client';
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { jsx as _jsx } from "react/jsx-runtime";
import { forwardRef, useCallback, useEffect, useMemo, useRef, useState, } from 'react';
import { debounce } from '@a-type/utils';
import { Input } from '../input/Input.js';
import { TextArea } from '../textArea/TextArea.js';
/**
 * An extension of TextField which keeps a local realtime value in state and
 * periodically reports changes to the parent. Use this to connect
 * to the API and update a value from the field directly.
 *
 * This component is optimistic and will not respond to external changes while focused.
 */
export const LiveUpdateTextField = forwardRef(function LiveUpdateTextField(_a, ref) {
    var { value, onChange, debounceMs = 500, onFocus, onBlur, textArea, type } = _a, rest = __rest(_a, ["value", "onChange", "debounceMs", "onFocus", "onBlur", "textArea", "type"]);
    const [displayValue, setDisplayValue] = useState(value || '');
    const ignoreUpdates = useRef(false);
    const didChange = useRef(false);
    const handleFocus = useCallback((ev) => {
        onFocus === null || onFocus === void 0 ? void 0 : onFocus(ev);
        ignoreUpdates.current = true;
    }, [onFocus]);
    const handleBlur = useCallback((ev) => {
        onBlur === null || onBlur === void 0 ? void 0 : onBlur(ev);
        ignoreUpdates.current = false;
        // immediately send update if the user typed anything.
        // otherwise pull the latest remote value
        if (didChange.current) {
            onChange === null || onChange === void 0 ? void 0 : onChange(displayValue);
        }
        else {
            setDisplayValue(value || '');
        }
        didChange.current = false;
    }, [onBlur, displayValue, onChange, value]);
    useEffect(() => {
        if (ignoreUpdates.current) {
            return;
        }
        setDisplayValue(value || '');
    }, [value]);
    // every once in a while, send an update to parent
    const debouncedOnChange = useMemo(() => debounce(onChange || (() => { }), debounceMs), [onChange, debounceMs]);
    // update local state instantly and parent eventually
    const handleChange = useCallback((ev) => {
        setDisplayValue(ev.target.value);
        debouncedOnChange(ev.target.value);
        didChange.current = true;
    }, [debouncedOnChange]);
    if (textArea) {
        return (_jsx(TextArea, Object.assign({ ref: ref, onFocus: handleFocus, onBlur: handleBlur, value: displayValue, onChange: handleChange, autoSize: true }, rest)));
    }
    else {
        return (_jsx(Input, Object.assign({ ref: ref, onFocus: handleFocus, onBlur: handleBlur, value: displayValue, onChange: handleChange, type: type }, rest)));
    }
});
//# sourceMappingURL=LiveUpdateTextField.js.map