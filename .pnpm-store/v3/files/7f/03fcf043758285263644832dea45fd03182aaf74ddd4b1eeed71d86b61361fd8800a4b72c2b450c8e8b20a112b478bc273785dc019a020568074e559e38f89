"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var react_1 = require("react");
var dateUtils_1 = require("./dateUtils");
var eventUtils_1 = require("./eventUtils");
var getDateEnabledIsTrue = function () { return true; };
/**
 * Manages selection and focus state for the calendar grid control.
 *
 * Focus is managed using the 'roving tabindex' method, where the currently
 * selected day element is given a tabindex=0, while others are given -1.
 * This makes the only logically focusable element the currently selected
 * day, so when the user tabs away from the calendar and then comes back,
 * their cursor is back on the current day.
 */
exports.default = (function (_a) {
    var onMonthChange = _a.onMonthChange, onChange = _a.onChange, _b = _a.value, value = _b === void 0 ? null : _b, rangeValue = _a.rangeValue, onRangeStartChange = _a.onRangeStartChange, onRangeChange = _a.onRangeChange, month = _a.month, year = _a.year, _c = _a.getDateEnabled, getDateEnabled = _c === void 0 ? getDateEnabledIsTrue : _c, _d = _a.defaultDate, defaultDate = _d === void 0 ? dateUtils_1.today : _d, rest = __rest(_a, ["onMonthChange", "onChange", "value", "rangeValue", "onRangeStartChange", "onRangeChange", "month", "year", "getDateEnabled", "defaultDate"]);
    if (!!rangeValue && !onRangeChange) {
        throw new Error('onRangeChange must be supplied if rangeValue is supplied');
    }
    var conflictingValues = !!rangeValue && value && process.env.NODE_ENV !== 'production';
    (0, react_1.useEffect)(function () {
        if (conflictingValues) {
            console.warn('You provided a value to useCalendarSelection in addition to a rangeValue. The value will be ignored in favor of the rangeValue. Remove value to avoid this warning.');
        }
    }, [conflictingValues]);
    // TODO: selected/hovered often get set at the same time. convert this to a
    // more sensible state machine
    var _e = (0, react_1.useState)((rangeValue && rangeValue.end) || value), selectedDate = _e[0], setSelectedDate = _e[1];
    var _f = (0, react_1.useState)(defaultDate), hoveredDate = _f[0], setHoveredDate = _f[1];
    var highlightedDate = hoveredDate || selectedDate;
    var _g = (0, react_1.useState)(null), pendingRangeStart = _g[0], setPendingRangeStart = _g[1];
    var isSelectingRange = !!pendingRangeStart;
    var handleKeyDown = (0, react_1.useCallback)(function (ev) {
        if (!(0, eventUtils_1.isEventTargetDay)(ev))
            return;
        var currentDate = highlightedDate || defaultDate;
        var newDate = new Date(currentDate);
        if (ev.key === 'ArrowLeft') {
            newDate.setDate(newDate.getDate() - 1);
        }
        else if (ev.key === 'ArrowRight') {
            newDate.setDate(newDate.getDate() + 1);
        }
        else if (ev.key === 'ArrowUp') {
            newDate.setDate(newDate.getDate() - 7);
        }
        else if (ev.key === 'ArrowDown') {
            newDate.setDate(newDate.getDate() + 7);
        }
        else if (ev.key === 'PageUp') {
            if (ev.altKey) {
                newDate = (0, dateUtils_1.addMonths)(newDate, -12);
            }
            else {
                newDate = (0, dateUtils_1.addMonths)(newDate, -1);
            }
        }
        else if (ev.key === 'PageDown') {
            if (ev.altKey) {
                newDate = (0, dateUtils_1.addMonths)(newDate, 12);
            }
            else {
                newDate = (0, dateUtils_1.addMonths)(newDate, 1);
            }
        }
        else if (ev.key === 'Home') {
            newDate.setDate(newDate.getDate() - newDate.getDay());
        }
        else if (ev.key === 'End') {
            newDate.setDate(newDate.getDate() + 6 - newDate.getDay());
        }
        else {
            return;
        }
        ev.preventDefault();
        // to preserve the validity of range selections,
        // prevent encompassing a disabled date in a range
        if (!(pendingRangeStart &&
            (0, dateUtils_1.rangeIncludesInvalidDate)(pendingRangeStart, newDate, getDateEnabled))) {
            setSelectedDate(newDate);
            setHoveredDate(null);
            if (!highlightedDate ||
                newDate.getMonth() !== highlightedDate.getMonth() ||
                newDate.getFullYear() !== highlightedDate.getFullYear()) {
                onMonthChange({
                    month: newDate.getMonth(),
                    year: newDate.getFullYear(),
                });
            }
        }
    }, [
        highlightedDate,
        setSelectedDate,
        onMonthChange,
        pendingRangeStart,
        getDateEnabled,
    ]);
    var previousMonthAndYear = (0, react_1.useRef)({ month: month, year: year });
    (0, react_1.useEffect)(function () {
        var _a = previousMonthAndYear.current, previousMonth = _a.month, previousYear = _a.year;
        // didn't actually change
        if (previousMonth === month && previousYear === year) {
            return;
        }
        var wentBackwards = (previousMonth > month && previousYear === year) || previousYear > year;
        if ((selectedDate === null || selectedDate === void 0 ? void 0 : selectedDate.getMonth()) !== month ||
            (selectedDate === null || selectedDate === void 0 ? void 0 : selectedDate.getFullYear()) !== year) {
            var movedDate = new Date(year, month, wentBackwards ? (0, dateUtils_1.getDaysInMonth)(month, year) : 1);
            setSelectedDate(movedDate);
            setHoveredDate(movedDate);
        }
        previousMonthAndYear.current = { month: month, year: year };
    }, [month, year, previousMonthAndYear]);
    var handleDaySelect = (0, react_1.useCallback)(function (value) {
        if (isSelectingRange &&
            (0, dateUtils_1.rangeIncludesInvalidDate)(pendingRangeStart, value, getDateEnabled)) {
            return;
        }
        setSelectedDate(value);
        if (!!rangeValue) {
            if (!pendingRangeStart) {
                // starting a range selection
                setPendingRangeStart(value);
                onRangeStartChange === null || onRangeStartChange === void 0 ? void 0 : onRangeStartChange(value);
            }
            else {
                // ending a range selection and committing the result
                // reset range start selection flag
                setPendingRangeStart(null);
                // for range operations, we 'normalize' the selected values
                // to determine which one is earlier, then inform the user of
                // the dates in the correct order
                if ((0, dateUtils_1.isBefore)(value, pendingRangeStart)) {
                    // the values are inverted (the user selected backwards), so reverse them
                    onRangeChange &&
                        onRangeChange({ start: value, end: pendingRangeStart });
                }
                else {
                    onRangeChange &&
                        onRangeChange({ start: pendingRangeStart, end: value });
                }
            }
        }
        else {
            onChange && onChange(value);
        }
    }, [
        onChange,
        !!rangeValue,
        setPendingRangeStart,
        pendingRangeStart,
        setSelectedDate,
        onRangeChange,
        getDateEnabled,
        isSelectingRange,
    ]);
    var handleDayHover = (0, react_1.useCallback)(function (value) {
        // to prevent invalid range selection,
        // don't allow hovering a range end
        // if the range would include disabled dates
        if (isSelectingRange &&
            (0, dateUtils_1.rangeIncludesInvalidDate)(pendingRangeStart, value, getDateEnabled)) {
            return false;
        }
        setHoveredDate(value);
        return true;
    }, [setHoveredDate, isSelectingRange, pendingRangeStart, getDateEnabled]);
    return __assign({ props: {
            onKeyDown: handleKeyDown,
        }, highlightedDate: highlightedDate, setHighlightedDate: setSelectedDate, onDaySelect: handleDaySelect, onDayHover: handleDayHover, onChange: onChange, onRangeChange: onRangeChange, value: value, onMonthChange: onMonthChange, month: month, year: year, rangeValue: !!pendingRangeStart
            ? { start: pendingRangeStart, end: highlightedDate }
            : rangeValue }, rest);
});
//# sourceMappingURL=useCalendarSelection.js.map