// @unocss-include
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useLongPress = void 0;
const react_1 = require("@use-gesture/react");
const react_2 = require("react");
const useAnimationFrame_js_1 = require("./useAnimationFrame.js");
const useStableCallback_js_1 = require("./useStableCallback.js");
const utils_1 = require("@a-type/utils");
/**
 * The press gesture must remain within THRESHOLD_DISTANCE until delay time has passed
 * to be considered a press.
 *
 * After delay, the gesture must remain within CANCEL_DISTANCE or be cancelled.
 */
const THRESHOLD_DISTANCE = 10;
const CANCEL_DISTANCE = 30;
function useLongPress({ onActivate, onDurationReached, duration = 2000, delay = 200, }) {
    const [gestureState, setGestureState] = (0, react_2.useState)('released');
    const [state, setState] = (0, react_2.useState)('idle');
    const timeoutRef = (0, react_2.useRef)(null);
    const ref = (0, react_2.useRef)(null);
    const gestureStateRef = (0, react_2.useRef)({
        distance: 0,
        startedAt: 0,
    });
    (0, react_1.useDrag)(({ first, cancel, elapsedTime, down, distance }) => {
        var _a;
        const totalDistance = Math.sqrt(Math.pow(distance[0], 2) + Math.pow(distance[1], 2));
        gestureStateRef.current.distance = totalDistance;
        if (elapsedTime < delay && totalDistance > THRESHOLD_DISTANCE) {
            cancel();
            setGestureState('released');
            return;
        }
        if (totalDistance > CANCEL_DISTANCE) {
            cancel();
            setGestureState('released');
            return;
        }
        if (first) {
            gestureStateRef.current.startedAt = Date.now();
            try {
                (_a = navigator === null || navigator === void 0 ? void 0 : navigator.vibrate) === null || _a === void 0 ? void 0 : _a.call(navigator, 200);
            }
            catch (err) {
                console.log(err);
            }
        }
        if (down) {
            setGestureState('pressed');
        }
        else {
            setGestureState('released');
        }
    }, {
        // triggerAllEvents: true,
        // preventDefault: true,
        target: ref,
    });
    (0, useAnimationFrame_js_1.useAnimationFrame)(() => {
        const gestureDuration = gestureStateRef.current.startedAt
            ? Date.now() - gestureStateRef.current.startedAt
            : 0;
        const distance = gestureStateRef.current.distance;
        // nothing to do in this case
        if (gestureState === 'released' &&
            (state === 'idle' || state === 'failed')) {
            return;
        }
        if (gestureState === 'released') {
            if (state === 'holding' || state === 'candidate') {
                // holding for longer than duration - activate
                if (gestureDuration >= duration + delay && distance < CANCEL_DISTANCE) {
                    onActivate();
                    setState('idle');
                }
                else {
                    // normal release before duration - cancel
                    setState('idle');
                }
            }
            else if (state === 'pending' && distance < THRESHOLD_DISTANCE) {
                setState('failed');
            }
        }
        else if (gestureState === 'pressed') {
            // begin a new press
            if (state === 'idle' || state === 'failed') {
                setState('pending');
            }
            else if (state === 'pending' && gestureDuration >= delay) {
                // begin holding after delay has passed
                setState('holding');
            }
            else if (distance > CANCEL_DISTANCE) {
                // cancel if moved too far
                setState('idle');
            }
            else if (gestureDuration >= duration + delay) {
                // not yet confirmed, but meets criteria
                setState('candidate');
            }
        }
    });
    const onDurationReachedStable = (0, useStableCallback_js_1.useStableCallback)(onDurationReached);
    (0, react_2.useEffect)(() => {
        if (state === 'failed') {
            const timeout = setTimeout(() => {
                setState('idle');
            }, 1000);
            return () => {
                clearTimeout(timeout);
            };
        }
        else if (state === 'candidate') {
            onDurationReachedStable();
        }
    }, [state, onDurationReachedStable]);
    const props = (0, react_2.useMemo)(() => ({
        onContextMenu: utils_1.preventDefault,
        style: {
            touchAction: 'none',
        },
    }), []);
    return {
        ref,
        timeoutRef,
        state,
        props,
    };
}
exports.useLongPress = useLongPress;
//# sourceMappingURL=useLongPress.js.map